# Dictionaries in Python

A dictionary is "an associative array, where arbitrary keys are mapped to values. The keys can be any object with '__hash__()' and '__eq__()' methods."

- Dictionaries have key:value pairs where keys are mapped to values.
    - The order of values doesn't matter and they should be thought of as collections. In versions of python after 3.6, they are ordered. However, if you want code to be compatible across multiple python versions, assume they are unordered.
    - Keys, must me of hashable type i.e. they should have a hash value that never changes. Since the key objects need to be hashable they can't be mutable objects. Hashable keys make dictionary inserts and lookups more efficient. If the key is not hashable, in order to find a particular key you have to (in the worst case) read and compare for equality all keys in the dictionary.
    - There are no restriction on the values. 
    - Dictionaries arew mutable data structures. Therefore they can't be used as keys to other dicts.
    - the keys dont have to be of the same type either !

Dictionaries are a cornerstone of Python. The language itself is built around dictionaries. Modules, classes, objects, globals(), locals(): all of these are dictionaries. Dictionaries have been central to Python from its very beginning.

To visualize the methods and attributes of any Python object, you can use dir(), which is a built-in function that serves that purpose. If you run dir({}) with an empty dictionary as an argument, then youâ€™ll be able to see all the methods and attributes that dictionaries implement.

Unlike sequences, lists, dictionaries are indexed by keys and not integer indices.

- Given a key k, the corresonding value can be got by using dict[k]. Similar syntax as list indexing. 

## Declaring Dictionaries 


```
d = {} # empty dictionary in python
another_dict = dict([(1, 'Geeks'), (2, 'For')]) # creating a dictionary from tuples
thisdict = {"brand": "Ford", "model": "Mustang", "year": 1964}

# adding to a dictionary
thisdict["color"] = "red"


```

## Iterating through Dictionaries

- Using a for loop, the keys are iterated upon
- a\_dict.items() returns a collection of (key,value) tuple pairs. a\_dict.keys() and a\_dict.values() return all the keys and values respectively. .key() returns a dictionary-view object.  
```
# using tuple unpacking
for key, value in a_dict.items():
```
- deleting an entry(key,value). One needs a list otherwise an error is displayed, saying the dictionary size has changed during iteration !
```
for key in list(prices.keys()):  # Use a list instead of a view
    if key == 'orange':
        del prices[key]  # Delete a key from prices
```
- adding an item (key, value) works with dict[key] = value, as long as they keys are distinct.

## Using Dictionary Comprehensions

In contrast to list comprehensions, they need two expressions separated with a colon followed by for and if (optional) clauses.
```
# creating a dictionary mapping from two lists. 
objects = ['blue', 'apple', 'dog']
categories = ['color', 'fruit', 'pet']
a_dict = {key: value for key, value in zip(categories, objects)}
```
Here, zip() receives two iterables (categories and objects) as arguments and makes an iterator that aggregates elements from each iterable. The tuple objects generated by zip() are then unpacked into key and value, which are finally used to create the new dictionary.

- specific items can be removed from being considered in the loop, check [here]{https://realpython.com/iterate-through-dictionary-python/}.

## Ordering Dictionaries 

- To sort a dictionary 
```
# the below code sorts the dictionary incomes.
sorted_income = {k: incomes[k] for k in sorted(incomes)}
```

The method, sorted(incomes) returns a list of sorted keys that you can use to generate the sorted dict.
The method can also be used to iterate though the dictionary in a sorted manner(wrt keys). It is also possible to iterate wrt sorted values. Use sorted(incomes, reverse=True) for reverse sort.


## Using Python Built-in's on Dictionaries

- map() is defined as map(function, iterable, ...) and returns an iterator that applies function to every item of iterable, yielding the results on demand.
- filter(), is defined as filter(function, iterable) and returns an iterator from those elements of iterable for which function returns True.
- itertools.cycle(iterable) : when one needs to iterate though an iterable multiple times
- itertools.chain(iterable1, iterable2) : when one needs to iterate over one and then the next iterable. 
- dictionary unpacking operator (\*\*) helps to merge two dictionaries into a new one
```
# merge two dictionaries into one
{**vegetable_prices, **fruit_prices}
```






